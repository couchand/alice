// Generated by CoffeeScript 1.4.0
(function() {
  var Alice, alice;

  Alice = (function() {

    function Alice() {
      this.LINE_COUNT_LIMIT = 300;
      this.LINE_LENGTH_LIMIT = 65;
      this.BLOCK_LINE_LIMITS = {
        '{': [300, 100, 40, 5]
      };
      this.BLOCK_LENGTH_LIMITS = {
        '(': [150, 50],
        '[': [500, 3]
      };
      this.BLOCK_OPEN = /[\[\(\{]/;
      this.BLOCK_CLOSE = /[\]\)\}]/;
      this.INVERSE = {
        '[': ']',
        ']': '[',
        '(': ')',
        ')': '(',
        '{': '}',
        '}': '{'
      };
      this.CLASS_NAME_REGEX = /^(\/\/.*\n|.|\n)*?class( |\t|\n)+([a-zA-Z][a-zA-Z0-9_]*)( |\t|\n)+/;
      this.CLASS_NAME_VALIDATOR = /^[A-Z][a-zA-Z]+$/;
      this.FINAL_VAR_REGEX = /final/;
      this.FINAL_VAR_STATIC_VALIDATOR = /static/;
      this.FINAL_VAR_NAME_VALIDATOR = /\s[A-Z_]+[\s=\(]/;
    }

    Alice.prototype.analyze = function(name, file) {
      this.name = name;
      this.file = file;
      if (!(this.file != null)) {
        this.file = this.name;
        this.name = false;
      }
      this.lines = this.file.split('\n');
      this.warnings = [];
      this.line = 0;
      this.checkClassName();
      this.checkFinalVarNames();
      this.checkFileLineCount();
      this.checkLineLength();
      this.checkConsistentWhitespace();
      this.checkTrailingWhitespace();
      this.checkBlockLengthCounts();
      return this.warnings;
    };

    Alice.prototype.alert = function(msg) {
      return this.warnings.push(msg);
    };

    Alice.prototype.checkLimit = function(actual, limit, msg) {
      if (actual > limit) {
        return this.alert("File " + this.name + " line " + (this.line + 1) + " " + msg + ": " + actual + " exceeds limit of " + limit);
      }
    };

    Alice.prototype.check = function(ok, msg) {
      if (!ok) {
        this.alert("File " + this.name + " line " + (this.line + 1) + " " + msg);
      }
      return !!ok;
    };

    Alice.prototype.checkFileLineCount = function() {
      return this.checkLimit(this.lines.length, this.LINE_COUNT_LIMIT, "has too many lines");
    };

    Alice.prototype.checkLineLength = function() {
      var line, _i, _ref, _results;
      _results = [];
      for (line = _i = 0, _ref = this.lines.length; 0 <= _ref ? _i < _ref : _i > _ref; line = 0 <= _ref ? ++_i : --_i) {
        this.line = line;
        _results.push(this.checkLimit(this.lines[line].length, this.LINE_LENGTH_LIMIT, "is too long", line));
      }
      return _results;
    };

    Alice.prototype.checkClassName = function() {
      var class_name, class_name_match, lines;
      this.line = 0;
      class_name_match = this.file.match(this.CLASS_NAME_REGEX);
      if (!this.check(class_name_match, "incorrectly formatted.  Unable to locate class name.")) {
        return;
      }
      lines = class_name_match[0].match(/\n/g);
      if (lines) {
        this.line = lines.length;
      }
      class_name = class_name_match[3];
      if (!this.name) {
        this.name = class_name;
      }
      this.check(class_name === this.name, "contains a class with a different name: " + class_name);
      return this.check(this.CLASS_NAME_VALIDATOR.test(class_name), "class should be named with CamelCase");
    };

    Alice.prototype.checkFinalVarNames = function() {
      var line, _i, _ref, _results;
      _results = [];
      for (line = _i = 0, _ref = this.lines.length; 0 <= _ref ? _i < _ref : _i > _ref; line = 0 <= _ref ? ++_i : --_i) {
        this.line = line;
        if (this.FINAL_VAR_REGEX.test(this.lines[line])) {
          this.check(this.FINAL_VAR_STATIC_VALIDATOR.test(this.lines[line]), "constants should be static");
          _results.push(this.check(this.FINAL_VAR_NAME_VALIDATOR.test(this.lines[line]), "constants should be named with ALL_CAPS"));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    Alice.prototype.checkConsistentWhitespace = function() {
      var first_whitespace_char, illegal_whitespace, line, _i, _ref, _results;
      first_whitespace_char = this.file.match(/( |\t)/);
      if (!this.check(first_whitespace_char, "has no whitespace.")) {
        return;
      }
      illegal_whitespace = (function() {
        switch (first_whitespace_char[0]) {
          case '\t':
            return /[ ]/;
          case ' ':
            return /\t/;
        }
      })();
      _results = [];
      for (line = _i = 0, _ref = this.lines.length; 0 <= _ref ? _i < _ref : _i > _ref; line = 0 <= _ref ? ++_i : --_i) {
        this.line = line;
        _results.push(this.check(!illegal_whitespace.test(this.lines[line]), "contains inconsistent whitespace"));
      }
      return _results;
    };

    Alice.prototype.checkTrailingWhitespace = function() {
      var line, _i, _ref, _results;
      _results = [];
      for (line = _i = 0, _ref = this.lines.length; 0 <= _ref ? _i < _ref : _i > _ref; line = 0 <= _ref ? ++_i : --_i) {
        this.line = line;
        _results.push(this.check(!/( |\t)+$/.test(this.lines[line]), "contains trailing whitespace"));
      }
      return _results;
    };

    Alice.prototype.checkBlockLengthCounts = function() {
      var block_chars, block_lines, block_to_close, char_limit, cursor, depth, line_limit, stack, this_char, token, _ref, _ref1;
      this.line = 0;
      cursor = 0;
      stack = [];
      while (cursor < this.file.length) {
        this_char = this.file[cursor];
        if (this_char.match(this.BLOCK_OPEN)) {
          stack.push({
            char: this_char,
            line: this.line,
            loc: cursor
          });
        } else if (this_char.match(this.BLOCK_CLOSE)) {
          block_to_close = stack.pop();
          if (!this.check((block_to_close != null ? block_to_close.char : void 0) === this.INVERSE[this_char], "unmatched " + (block_to_close != null ? block_to_close.char : void 0) + ", found " + this_char)) {
            return;
          }
          block_lines = this.line - block_to_close.line + 1;
          block_chars = cursor - block_to_close.loc - 1;
          depth = ((function() {
            var _i, _len, _results;
            _results = [];
            for (_i = 0, _len = stack.length; _i < _len; _i++) {
              token = stack[_i];
              if (token.char === this.INVERSE[this_char]) {
                _results.push(token.char);
              }
            }
            return _results;
          }).call(this)).length;
          line_limit = (_ref = this.BLOCK_LINE_LIMITS[block_to_close.char]) != null ? _ref[depth] : void 0;
          char_limit = (_ref1 = this.BLOCK_LENGTH_LIMITS[block_to_close.char]) != null ? _ref1[depth] : void 0;
          if (line_limit) {
            this.checkLimit(block_lines, line_limit, "`" + this.INVERSE[this_char] + "` block has too many lines for depth " + depth);
          }
          if (char_limit) {
            this.checkLimit(block_chars, char_limit, "`" + this.INVERSE[this_char] + "` block has too many chars for depth " + depth);
          }
        } else if (this_char.match(/\n/)) {
          this.line++;
        }
        cursor++;
      }
    };

    return Alice;

  })();

  alice = new Alice();

  module.exports = alice;

}).call(this);
